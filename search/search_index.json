{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GLADOS","text":"<p>GLADOS is an Automated Science Pipeline, allowing for computational research experiments to get aggregated results from multiple experiment runs easily. Currently developed by seniors at Rose-Hulman Institute of Technology, the goal is to develop a system that makes it simple to run experiments and gather relevant data, through a low cost, open-source, community-built project.</p> <p>When you're on the Rose-Hulman internal network, you can access the deployed project at https://glados.csse.rose-hulman.edu.</p>"},{"location":"#usage","title":"Usage","text":"<p>To run an experiment on a running copy of the system, get started here.</p>"},{"location":"#development","title":"Development","text":"<p>To set up a new machine for development, follow the developer installation guide.</p> <p>To get familiar with the components of the system, check out the Best Practices guide.</p>"},{"location":"about/","title":"About","text":"<p>GLADOS, the Automated Science Pipeline, started when Dr. Jason Yoder, a CSSE Professor at Rose-Hulman Institute of Technology, found himself building the same interface for many different computational research projects over his years of research. Finding a natural need to make this repeated process easier to set up, the project began in 2021 as a senior capstone project, with continuous iterations done by different senior capstone project teams each academic year. The goal is to provide a useful website for people with hard to run experiments that they need to iterate on, as GLADOS will speed up the time running those experiments take while also providing a nice interface to view the experiment results on.</p> <p>The 2024-25 team completed the Kubernetes system migration and created the scalable VMs server infrastructure. They migrated the database from Firebase to MongoDB and authentication from Firebase authentication to Auth.js. They also improved the system's usability by adding features like default experiments, charting, cancellation, archiving, deletion, collapsing, and expanding experiments.</p> <p>Below is the most recent poster shown at the Rose Show for the 24-25 year.</p> <p></p>"},{"location":"about/#faq","title":"FAQ","text":"<ul> <li>Why 'GLADOS'?</li> </ul> <p>GLADOS stands for 'General Learning and Automatic Discovery for Operationalizing Science', which is a mouthful, but has a memorable acronym, taking inspiration from the Portal series.</p> <ul> <li>What technology does this project run on?</li> </ul> <p>GLADOS uses React and Next.js on the frontend, Python on the backend, and MongoDB for data storage, with Auth.js for account management. The production server currently runs on a Kubernetes cluster within the Rose-Hulman firewall, utilizing multiple machines and VMS also provided by Rose-Hulman, giving Kubernetes enough processing power to properly allocate multiple experiments being run at once.</p> <ul> <li>Future goals?</li> </ul> <p>GLADOS aims to become more secure in order to eventually broader its scope to be more open source. In addition, getting GLADOS to be at least semi-functional from a mobile device would allow for more flexibility in its usage. These goals are being handed off to next year's senior capstone project team.</p>"},{"location":"bioai/hw8/","title":"BioAI HW 8 User Guide","text":"<p>This guide is intended for students in CSSE314 BioAI to utilize the GLADOS system to run their completed code.</p> <p>Warning</p> <p>HW8 needs to be completed in order for this to run. The code needs to have succeeded in running the evolution to completion (but it does not need to be a great behavior, just some completed behavior).</p>"},{"location":"bioai/hw8/#step-1-format-the-zip-file-for-the-project","title":"Step 1: Format the .zip File for the Project","text":"<p>There are a couple things that need to be changed in the HW8 files to ensure that this project runs on GLADOS.</p> <p>First, in <code>fitness_function</code>, this line needs to be changed:</p> <pre><code>    BEFORE: robotid = p.loadURDF(\"./URDF_Files/armsBody.urdf\")\n    AFTER:  robotid = p.loadURDF(\"../URDF_Files/armsBody.urdf\")\n</code></pre> <p>Note</p> <p>If you do not make the change above, GLADOS will error. The error will look similar to this:</p> <p></p> <p>Then, zip all of the project files into a single <code>.zip</code> and give it a appropriate name. (e.g. bioAI_HW8_{RHITUSERNAME}.zip).</p> <p>Here is a screenshot of the files in the source_code folder to be zipped:</p> <p></p>"},{"location":"bioai/hw8/#step-2-create-and-run-a-new-experiment","title":"Step 2: Create and Run a New Experiment","text":"<p>First, log in with your Google or GitHub account to access the GLADOS Homepage. This is the screen that wil be presented when the user is logged in:</p> <p></p>"},{"location":"bioai/hw8/#information-step","title":"Information Step","text":"<p>In the top left of the page, select the  button to open the new experiment panel.</p> <p>Fill in the following details:</p> <ul> <li>Name: Any appropriate name (e.g., BioAI-HW8_{RHITUSERNAME})</li> <li>Trial Result File: Set to Homework8_Results.csv</li> <li>Trial's Extra File: Set to ./</li> <li>Trial Timeout (hours): 5 (default)</li> <li>Executable File: Set to glados_experiment.py</li> </ul> <p>Once completed, click the Next button.</p> <p>Example:</p> <p></p>"},{"location":"bioai/hw8/#parameter-step","title":"Parameter Step","text":"<p>Next, set up the parameters that GLADOS will handle during the experiment. </p> <p>Select <code>float</code> from the Parameter list. A new float will appear in the parameters section below. This <code>float</code> parameter needs to include the following information:</p> <ul> <li>name: mr</li> <li>min: 0.2</li> <li>max: 0.5</li> <li>step: 0.1</li> </ul> <p>Now select <code>integer</code> from the Parameter list. A new integer will appear in the parameters section below. This <code>integer</code> parameter nees to include the following information.</p> <ul> <li>name: seed</li> <li>min: 0</li> <li>max: 10</li> <li>step: 1</li> </ul> <p>When completed, the parameters section will look like this:</p> <p></p> <p>When completed, click Next.</p>"},{"location":"bioai/hw8/#user-defined-constants","title":"User Defined Constants","text":"<p>These constants ensure that GLADOS and the inserted code recognize the correct variables. Copy and paste the following block into the User Defined Constants section to map the parameter mr to the mutation_probabilty variable and the parameter seed to the random_seed variable.</p> <pre><code>num_inputs = 4\nnum_classes = 4\nnum_solutions = 10\nhidden_activations = sigmoid\noutput_activation = sigmoid\nnum_parents_mating = 5\nnum_generations = 2\nmutation_probability = {mr}\nparent_selection_type = rank\ncrossover_type = scattered\nmutation_type = random\nkeep_parents = 0\nrandom_seed = {seed}\n</code></pre> <p>When pasted, click Next.</p>"},{"location":"bioai/hw8/#post-process","title":"Post Process","text":"<p>Leave this box unchecked. Click Next.</p>"},{"location":"bioai/hw8/#confirmation-step","title":"Confirmation Step","text":"<p>This step reviews the experiment setup. If the previous steps were followed correctly, the confirmation page should resemble the following:</p> <pre><code>  {\n  \"hyperparameters\": [\n    {\n      \"name\": \"mr\",\n      \"default\": -1,\n      \"min\": \"0.2\",\n      \"max\": \"0.5\",\n      \"step\": \".1\",\n      \"type\": \"float\",\n      \"useDefault\": false\n    },\n    {\n      \"name\": \"seed\",\n      \"default\": -1,\n      \"min\": \"0\",\n      \"max\": \"10\",\n      \"step\": 1,\n      \"type\": \"integer\",\n      \"useDefault\": false\n    }\n  ],\n  \"name\": \"BioAI-HW8-{RHITUSERNAME}\",\n  \"description\": \"\",\n  \"trialExtraFile\": \"\",\n  \"trialResult\": \"Homework8_Results.csv\",\n  \"scatterIndVar\": \"\",\n  \"scatterDepVar\": \"\",\n  \"dumbTextArea\": \"\\nnum_inputs = 4\\nnum_classes = 4\\nnum_solutions = 10\\nhidden_activations = sigmoid\\noutput_activation = sigmoid\\nnum_parents_mating = 5\\nnum_generations = 2\\nmutation_probability = {mr}\\nparent_selection_type = rank\\ncrossover_type = scattered\\nmutation_type = random\\nkeep_parents = 0\\nrandom_seed = {seed}\",\n  \"timeout\": 5,\n  \"scatter\": false,\n  \"keepLogs\": true,\n  \"workers\": 1,\n  \"file\": \"679e806160f8c8d0c659037d\",\n  \"status\": \"CREATED\",\n  \"experimentExecutable\": \"glados_experiment.py\"\n}\n</code></pre> <p>Click Next.</p>"},{"location":"bioai/hw8/#dispatch-step","title":"Dispatch Step","text":"<p>If this is the users first experiment, the \"Recent Files\" section in the Dispatch Step will be empty. To add a file, drag the <code>.zip</code> file created in Step 1 into the Upload dropbox:</p> <p></p> <p>Once uploaded, the file will appear as successfully selected for the experiment:</p> <p></p> <p>Click the Dispatch button to send the experiment to GLADOS.</p> <p>Note</p> <p>If the experiment fails, the result on GLADOS will look like this:</p> <p></p> <p>If this happens, review the above steps to ensure that the experiment was set up correctly. If you are confused why it failed, you can use the System Log button to review the logging of the experiment run to see possible reasons for failure.</p> <p>Note: You will have to scroll through the log file to find where the error happens. It may not be obvious by just briefly scanning the log file.</p> <p>See the FAQ section if you are repeatedly unable to run an experiment.</p>"},{"location":"bioai/hw8/#3-reviewing-results","title":"3. Reviewing Results","text":"<p>After the experiment completes, several buttons appear to review and download data:</p> <ul> <li>Download Results: Click to download the raw <code>.csv</code> file.</li> <li>Download Project Zip: Click to download the <code>.zip</code> file containing project and run data.</li> <li>See Graph: Click to open an interactive graphing module to visualize variable changes during the experiment. For more detailed informtion, view the gif below:</li> </ul> <p></p>"},{"location":"bioai/hw8/#4-faq","title":"4. FAQ","text":""},{"location":"bioai/hw8/#glados-dev-team-contact-information","title":"GLADOS Dev Team Contact Information","text":"<p>For help with running this project, contact Dr. Yoder via email or Teams and he can forward any concerns or questions to the GLADOS Dev Team.</p> <p>If there are any errors or bugs with GLADOS, a report can be submitted via the Report button at the top right of the GLADOS page.</p>"},{"location":"deafult-exp-guides/addNums/","title":"AddNums Experiment","text":""},{"location":"deafult-exp-guides/addNums/#description","title":"Description","text":"<p>The <code>AddNums</code> experiment is a simple Python script that demonstrates how to set up GLADOS with basic parameters. The script performs basic arithmetic operations (addition and subtraction) on two input parameters (<code>x</code> and <code>y</code>) and writes the results to a CSV file. This experiment showcases two ways to gather additional information: 1. Trial's Extra File: Gathers the designated file that a run of the file generates and places in a zip to be uploaded when         the experiment completes 2. Trial Result: Integrates the information from a 2 line csv of headers and values that the file run generates         and adds them to the result csv that is being uploaded</p>"},{"location":"deafult-exp-guides/addNums/#parameters","title":"Parameters","text":"<p>The script accepts the following parameters via a configuration file: - <code>x</code>: The first integer input for the arithmetic operations. - <code>y</code>: The second integer input for the arithmetic operations.</p>"},{"location":"deafult-exp-guides/addNums/#example-configuration-file","title":"Example Configuration File","text":"<pre><code>[DEFAULT]\nx = 5\ny = 3\n</code></pre>"},{"location":"deafult-exp-guides/addNums/#output","title":"Output","text":"<p>The script generates a CSV file named <code>AddNumResult.csv</code> in the current working directory. The file contains two rows: 1. Headers: Describes the columns in the CSV file. 2. Values: Contains the results of the arithmetic operations.</p>"},{"location":"deafult-exp-guides/addNums/#example-output","title":"Example Output","text":"<p>If <code>x = 5</code> and <code>y = 3</code>, the contents of <code>AddNumResult.csv</code> will be: <pre><code>Addition,Subtraction\n8,2\n</code></pre></p>"},{"location":"deafult-exp-guides/addNums/#notes","title":"Notes","text":"<ul> <li>The <code>AddNums</code> script is designed to demonstrate config files and show an output for GLADOS.</li> <li>Both Trial's Extra File and Trial Result functionalities can be used simultaneously to gather and analyze the output data.</li> <li>Ensure that the configuration file (<code>config.ini</code>) is correctly formatted and contains valid integer values for <code>x</code> and <code>y</code>.</li> <li>The generated <code>AddNumResult.csv</code> file will be overwritten each time the script is executed, so make sure to save or rename the file if needed.</li> <li>The script requires Python 3.x and the <code>configparser</code> module to run successfully.</li> </ul>"},{"location":"deafult-exp-guides/addNums/#full-python-file","title":"Full Python File","text":"<pre><code>import csv\nimport sys\nimport configparser\n\n# pylint: disable-next=pointless-string-statement\n\"\"\"\nThis experiment demonstrates outputting additional information to a file\nand telling the system to gather the data from that file.\n\nThere are two different ways to gather additional information from an experiment\n    - Trial's Extra File: Gathers the designated file that a run of the file generates and places in a zip to be uploaded when\n        the experiment completes\n    - Trial Result: Integrates the information from a 2 line csv of headers and values that the file run generates\n        and adds them to the result csv that is being uploaded\n\nHow to tell if they worked\n    - Trial's Extra File: You can download a zip file that contains the different output files specified\n    - Trial Result: The result csv downloaded has been expanded with information from the specified file\n\n\nExample settings for a run that demonstrates this: (Any Fields not specified can be left blank or to whatever their default is)\n\nInfo:\nTrial Result: AddNumResult.csv\nIf you want a collection of each CSV this experiment runs:\n    Trial's Extra File: AddNumResult.csv\nBoth can be used at the same time\n\nParameters:\nx, 1, 1, 10, 1\ny, 1, 1, 10, 1\n\"\"\"\n\n# pylint: disable=glados-print-used\n\ndef main():\n    config = configparser.ConfigParser()\n    args = sys.argv[1:]\n    configFile = args[0]\n    config.read(configFile)\n    x = int(config[\"DEFAULT\"][\"x\"])\n    y = int(config[\"DEFAULT\"][\"y\"])\n    with open('AddNumResult.csv', 'w', encoding=\"utf8\") as result:\n        writer = csv.writer(result)\n        writer.writerow(['Addition', 'Subtraction'])\n        writer.writerow([x + y, x - y])\n\n    print(\"done\")\n    return 0\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"developerhelp/helpful_commands/","title":"Helpful Commands","text":"<p>This page will eventually replace the cheatsheet.md page.</p> <p>This will be a page describing tasks that are simple but may be helpful to developers in the future.</p>"},{"location":"developerhelp/helpful_commands/#joining-a-node-to-the-cluster","title":"Joining a node to the cluster","text":"<p>Run the following command on the control-plane.</p> <pre><code>kubeadm token create --print-join-command\n</code></pre> <p>This will give you a command printed to the terminal. You run the given command on the worker you are attempting to join to the cluster.</p> <p>Example:</p> <pre><code>sudo kubeadm join 123.123.123.123:1234 --token abcde.123465fiasda --discovery-token-ca-cert-hash sha256:1234...abcdef\n</code></pre>"},{"location":"developerhelp/helpful_commands/#pipenv-usage","title":"Pipenv usage","text":"<p>To activate the backend python environment in the terminal, run <code>source apps/backend/.venv/Scripts/activate</code></p> <p>To activate the documentation python environment in the terminal, run <code>source docs/.venv/Scripts/activate</code></p> <p>To disable, run <code>deactivate</code></p>"},{"location":"developerhelp/helpful_commands/#tips","title":"Tips","text":""},{"location":"developerhelp/helpful_commands/#aliases","title":"Aliases","text":"<p>You can use command aliases to avoid remembering long, but commonly used terminal commands, or even multiple commands. I (Alan) personally found making aliases for git commands to be useful for general development, even outside of this project. There are many guides online showing how to set up aliases on various terminal environments, it may differ depending on what terminal you use.</p>"},{"location":"developerhelp/setup/","title":"GLADOS Setup for Developers","text":"<p>We use VS Code dev containers for our developer environment because it greatly simplifies dependency setup.</p> <p>There are 2 ways to deploy GLADOS that we will cover in this document:</p> <ol> <li> <p>Gitpod developer environment</p> </li> <li> <p>Local developer environment via Docker</p> </li> </ol>"},{"location":"developerhelp/setup/#dev-technologies-used","title":"Dev Technologies Used","text":""},{"location":"developerhelp/setup/#rose-hulman-vm","title":"Rose-Hulman VM","text":"<p>To make development not intensive on an individual's laptop (because we know how a Rose laptop runs after 4 years), we decided to work with the CSSE department to set up another VM dedicated to GLADOS development where all development environments live, called glados-forge. To learn more about this VM, go to the VMs page.</p>"},{"location":"developerhelp/setup/#tilt","title":"Tilt","text":"<p>Tilt is the technology that was found to enable live updating for a Kubernetes-based system. With this enabled, whenever a developer makes a change in any of the images (frontend, backend, or runner), it automatically updates the image and hot refreshes the page to show the change without any manual steps. This saves the process of rebuilding images and increases development speed greatly.</p>"},{"location":"developerhelp/setup/#vs-code-dev-containers-ssh","title":"VS Code + Dev Containers + SSH","text":"<p>VS Code has great integrations with Dev Containers and the ability to connect directly to the GLADOS image that has been spun up on the glados-forge server. All dependencies and extensions for development should also be installed.</p>"},{"location":"developerhelp/setup/#using-gitpod","title":"Using Gitpod","text":"<p>From Gitpod.io:</p> <p>Gitpod is a zero-trust platform that provides automated and standardized development environments in your own infrastructure\u2014whether on your local machine, in your cloud account (VPC), or on-prem. It streamlines coding workflows and boosts collaboration by letting teams spin up secure, preconfigured dev environments quickly and consistently.</p> <p>So, what does that mean?</p> <p>We install a program on our virtual machine (glados-forge) and that virtual machine can then spin up new virtual machines dispatched through a web GUI for developers to access.</p>"},{"location":"developerhelp/setup/#how-to-use-gitpod","title":"How to use Gitpod","text":"<ul> <li> <p>Go to Gitpod (after you have joined the organization)</p> </li> <li> <p>Click into the \"Projects\" tab</p> </li> <li> <p>You should see a project called GLADOS, hover over that and click \"Create Environment\"</p> </li> </ul> <p>Note</p> <p>You only need to do this the first time, as you can reuse the environment after it was created the first time by clicking the \"play\" button. Creating multiple environments will use up extra space on the glados-forge VM and could cause problems in the future. Try to only maintain one environment unless there is a specific use case.</p> <ul> <li>This will open a new environment for you based on the main branch.</li> </ul>"},{"location":"developerhelp/setup/#if-you-are-on-windows-you-have-to-do-the-following","title":"If you are on Windows, you have to do the following","text":"<ol> <li> <p>Press Windows key + R</p> </li> <li> <p>Type .ssh and then click run</p> </li> <li> <p>If a file named \"config\" exists open it, if not create one.</p> </li> <li> <p>Put the following into that file (make sure to update with your Windows username):</p> </li> </ol> <pre><code>Include \"C:/Users/{PUT YOUR USER HERE}/.ssh/code_gitpod_flex.d/config\"\n</code></pre> <ul> <li> <p>Now you can click the the \"Open VS Code\" button</p> </li> <li> <p>After it loads you should be in the Monorepo folder on the dev environment</p> </li> </ul>"},{"location":"developerhelp/setup/#local-via-docker","title":"Local Via Docker","text":""},{"location":"developerhelp/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Install Docker Desktop</p> </li> <li> <p>Setup Ubuntu in WSL2</p> </li> </ul>"},{"location":"developerhelp/setup/#how-to-setup","title":"How to setup","text":"<p>On Windows you have to run the dev container from WSL2 due to Windows not supporting the live updating in Tilt.</p> <p>Skip step 2 if you are not using Windows!</p> <ol> <li> <p>Clone the Monorepo to your machine</p> </li> <li> <p>Run the start_in_wsl.py script</p> <pre><code>python3 .devcontainer/start_in_wsl.py\n</code></pre> </li> <li> <p>Now you should have a VS Code window open to the Monorepo that has been copied to your WSL2 instance</p> </li> <li> <p>In the bottom right of the VS Code window you should be prompted to open as a dev container, if not press F1 and search for \"Rebuild\", click \"Rebuild and Reopen in Container\"</p> </li> <li> <p>You should then have the Monorepo open inside of a dev container</p> </li> </ol>"},{"location":"developerhelp/setup/#getting-started-with-the-monorepo","title":"Getting Started with the Monorepo","text":"<p>Now that you are inside of a dev container, we will go over how to get a running copy of GLADOS.</p> <ol> <li> <p>Copy the secret.yaml file into kubernetes_init/kubernetes_secrets</p> </li> <li> <p>From the root of the Monorepo run the following command:</p> <pre><code>tilt up\n</code></pre> </li> <li> <p>Now control + click on the URL that is shown: http://localhost:10350</p> </li> <li> <p>You will see the Tilt interface, wait for the top to say 10/10, and then go to http://localhost:3000</p> </li> </ol> <p>Now you have a running version of GLADOS!</p> <p>See Best Practices for tips on how to utilize the system in the best way for development.</p>"},{"location":"developerhelp/setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"developerhelp/setup/#what-if-the-tasks-dont-run","title":"What if the Tasks don\u2019t run?","text":"<p>GitPod may have an issue from time to time with successfully running all the tasks after setting up the environment. Stop and rerun the environment to see if the problem resolved. This should work 99% of the time.</p>"},{"location":"developerhelp/setup/#what-is-the-ports-are-not-working-correctly","title":"What is the ports are not working correctly?","text":"<p>Go to the Ports tab in VS Code and make sure that the ports are set to the correct ones. you can delete the port and re-add it to the correct port (e.g. 3000) fix the issue. If that does not work, try restarting the dev container.</p>"},{"location":"documentation/guide/","title":"Overview","text":"<p>Documentation is powered by MkDocs with MkDocs Material, hosted on Github Pages. Older docs still exist on the Monorepo's Github Wiki, but it is being migrated to this page. </p>"},{"location":"documentation/guide/#setup","title":"Setup","text":"<p>For developers, a MkDocs setup is included as part of the dev install script. When working with the documentation locally, remember to activate the venv:</p> <pre><code>source docs/.venv/Scripts/activate\n</code></pre> <p>Otherwise, mkdocs commands will likely not work.</p> <p>To exit the venv, while in the venv, run</p> <pre><code>deactivate\n</code></pre> <p>Note</p> <p>For any mkdocs commands, you must be in the outermost <code>docs</code> folder for it to find your files correctly.</p>"},{"location":"documentation/guide/#updating","title":"Updating","text":"<p>Updating documentation is as simple as updating Markdown files, all contained within the <code>docs</code> folder in the Monorepo. </p> <p>To preview your changes, this will build the site locally, with automatic updates as you make changes: <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"documentation/guide/#deploying","title":"Deploying","text":"<p>With Github Actions, updates to the <code>main</code> branch will automatically build and deploy the static site to the <code>gh-pages</code> branch.</p> <p>To deploy manually, run <pre><code>mkdocs gh-deploy --force\n</code></pre></p> <p>This updates the <code>gh-pages</code> branch with the static site. Keep in mind, if there are unpublished changes, it will display those changes as well, so beware!</p> <p>To preview what files will be generated and published, this generates the static website files under <code>docs/site/</code>: <pre><code>mkdocs build\n</code></pre></p>"},{"location":"documentation/guide/#notes","title":"Notes","text":"<p>There are many MkDocs Plugins that may be useful while updating documentation, so consider them as this documentation evolves! More information about plugins here.</p> <p>The Github Action for automatic deployment was found here, slightly changed.</p> <p>If time allows for it, consider looking at Sphinx instead, for documentation. It seems more advanced, with more features and apparently better code integration with documentation, but may be harder to set up and learn.</p>"},{"location":"infrastructure/cluster_update/","title":"Cluster update","text":"<p>This is a guide for updating the Kubernetes version of the cluster.</p> <p>This document will be similar to the official kubeadm upgrade guide.</p> <p>Warning</p> <p>This could change based on kubeadm version! Compare with the guide at the top while updating!</p> <p>First we are going to connect to the glados control node.</p> <p>Now we need to change the Kubernetes repo version that we are using.</p> <p>Run the following command.</p> <pre><code>sudo vim /etc/apt/sources.list.d/kubernetes.list\n</code></pre> <p>In my case, I see:</p> <pre><code>deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /\n</code></pre> <p>I am going to update from <code>v1.31</code> to <code>v1.32</code>, so I will change that here.</p> <p>Press :wq to save this update to the file.</p> <p>To avoid an error in the <code>sudo apt update</code>, we need to update the signing of the k8s repo:</p> <pre><code>curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.32/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg\n</code></pre> <p>Obviously replace <code>v1.32</code> with your version.</p> <p>Next we run:</p> <pre><code>sudo apt update\nsudo apt-cache madison kubeadm\n</code></pre> <p>This will update all of our package repos to make sure that we are going to download the right versions of everything.</p> <p>Now we run the following commands:</p> <pre><code># replace x in 1.32.x-* with the latest patch version\nsudo apt-mark unhold kubeadm &amp;&amp; \\\nsudo apt-get update &amp;&amp; sudo apt-get install -y kubeadm='1.32.1-*' &amp;&amp; \\\nsudo apt-mark hold kubeadm\n</code></pre> <p>This will update our kubeadm and then hold the version.</p> <p>Let's verify:</p> <pre><code>kubeadm version\n</code></pre> <p>You should see something like:</p> <pre><code>kubeadm version: &amp;version.Info{Major:\"1\", Minor:\"32\", GitVersion:\"v1.32.1\", GitCommit:\"e9c9be4007d1664e68796af02b8978640d2c1b26\", GitTreeState:\"clean\", BuildDate:\"2025-01-15T14:39:14Z\", GoVersion:\"go1.23.4\", Compiler:\"gc\", Platform:\"linux/amd64\"}\n</code></pre> <p>Now we can verify the upgrade plan:</p> <pre><code>sudo kubeadm upgrade plan\n</code></pre> <p>If all is well, then it is time to upgrade (this command is given in the terminal):</p> <pre><code>sudo kubeadm upgrade apply v1.32.1\n</code></pre> <p>Now we wait... that should eventually say:</p> <pre><code>[upgrade] SUCCESS! A control plane node of your cluster was upgraded to \"v1.32.1\".\n</code></pre> <p>Now we need to upgrade the nodes:</p> <p>First connect to the worker node that needs upgrade.</p> <p>Next upgrade kubeadm again:</p> <pre><code># replace x in 1.32.x-* with the latest patch version\nsudo apt-mark unhold kubeadm &amp;&amp; \\\nsudo apt-get update &amp;&amp; sudo apt-get install -y kubeadm='1.32.x-*' &amp;&amp; \\\nsudo apt-mark hold kubeadm\n</code></pre> <p>Now run: <pre><code>sudo kubeadm upgrade node\n</code></pre></p> <p>Now we need to drain the node from the control plane:</p> <pre><code># execute this command on a control plane node\n# replace &lt;node-to-drain&gt; with the name of your node you are draining\nkubectl drain &lt;node-to-drain&gt; --ignore-daemonsets\n</code></pre> <p>Next:</p> <pre><code># replace x in 1.32.x-* with the latest patch version\nsudo apt-mark unhold kubelet kubectl &amp;&amp; \\\nsudo apt-get update &amp;&amp; sudo apt-get install -y kubelet='1.32.x-*' kubectl='1.32.x-*' &amp;&amp; \\\nsudo apt-mark hold kubelet kubectl\n</code></pre> <p>Now restart the kublet:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart kubelet\n</code></pre> <p>Bring the node back:</p> <pre><code># execute this command on a control plane node\n# replace &lt;node-to-uncordon&gt; with the name of your node\nkubectl uncordon &lt;node-to-uncordon&gt;\n</code></pre> <p>Repeat this for all of the worker nodes.</p> <p>Congrats! The cluster is updated.</p> <p>You can run <code>kubectl get nodes</code> and it will show the version of every node.</p>"},{"location":"infrastructure/kubernetes/","title":"Kubernetes","text":"<p>This section gives an overview and an introduction to Kubernetes, aiming to explain concepts to someone brand new to virtualization and distributed systems.</p> <p>For those who have some familiarization with virtualization, and/or have worked with Docker, skip ahead.</p>"},{"location":"infrastructure/kubernetes/#virtualization","title":"Virtualization","text":"<p>Imagine a program that simulated everything that your laptop could do, including running an OS, installing programs, and searching the web. This program, called a Virtual Machine, or VM, could be ran on an actual, physical computer or server. The program would have it's own storage, processes, and interactions separate from the physical machine it is running on, even though it is all running on one physical machine.</p> <p>Now imagine a computer system with everything stripped out of it except for the bare minimums required to run a single program, and have this system be simulated by a program. This is called a container. Much like a VM, it has all of its resources isolated from the physical machine it is running on.</p> <p>Both of these allow for multiple identical virtual systems to be created and ran on any computer environment, making them versatile for development and usage.</p>"},{"location":"infrastructure/kubernetes/#images","title":"Images","text":"<p>Containers are built off of images, which dictate the starting configuration and environment. Oftentimes, images are built off of other images, to achieve a more specific use case. Docker Hub, like Github, stores these images in a registry, allowing for other systems to pull images and build containers from them.</p> <p>GLADOS has images made for each process in the system: the frontend, the backend, the database, and the runners. From them, we build containers that interact together within a Kubernetes cluster. This is explained in more detail later on in this page.</p>"},{"location":"infrastructure/kubernetes/#kubernetes-terminology","title":"Kubernetes Terminology","text":"<p>This contains a list of brief definitions that Kubernetes uses to describe different aspects of the system.</p> <code>Pod</code> <p>A single container or group of containers, runs an image. This is normally managed by other resources, like Deployments or Jobs. Reference</p> <code>Node</code> <p>A machine within the Kubernetes cluster. This can be anything from a server to VMs, and Pods run using the Node's resources (CPU, memory, storage, etc). Reference</p> <code>Cluster</code> <p>The overarching Kubernetes system, consisting of (usually) multiple Nodes. Each cluster has a control-plane Node that manages the interactions within the system. To learn what a cluster needs to manage the system, skip ahead.</p> <p> Image originated from Kubernetes website.</p> <code>Deployment</code> <p>Manages Pod states through Replica Sets. Reference</p> <code>Replica Set</code> <p>Maintains a set of replica Pods, all identical, to reach a certain number of Pods. Reference</p> <code>Job</code> <p>Creates Pods until one successfully completes its task. Can wait for multiple successful completions. Reference</p> <code>Service</code> <p>Exposes a Pod, or group of Pods, to the cluster network, for interaction. Reference</p> <code>Persistent Volume</code> <p>Storage provisioned from physical storage, useful to retain data independent of Pods, like database data. To learn a bit more about storing data with Kubernetes, skip ahead. Reference</p>"},{"location":"infrastructure/kubernetes/#creating-a-cluster","title":"Creating a Cluster","text":"<p>Each cluster requires these things to run properly:</p> <ol> <li>Container Runtime, which runs the containers. This needs to be selected, with multiple options.</li> <li>Container Network Interface, or CNI, which manages Pod-to-Pod communication. This needs to be selected, with compatability with the Container Runtime.</li> <li>Kubelet, which manages the nodes.</li> <li>kube-apiserver, which manages resources. This is installed automatically as part of the control plane node.</li> <li>kubectl, which lets the user interact with the kube-apiserver, allowing you to view and make changes to the cluster.</li> </ol> <p>There are many tools that help in creating a cluster, some of which abstract parts of setting this up. Minikube creates a locally hosted cluster, abstracting a lot of the setup for simple testing. Kubeadm is a more advanced tool, requiring configuration and networking setup. On the production server, we used kubeadm to create the cluster, with Flannel as a CNI and CRI-O as the container runtime. We have used minikube to test the system setup locally.</p> <p>Note</p> <p>Minikube is currently not part of the installation process, but will be added to the developer installation process. Additionally, detailed steps to set up a kubernetes system will be added in the near future.</p>"},{"location":"infrastructure/kubernetes/#networking","title":"Networking","text":"<p>By default, pods are closed off from other pods. To connect to other pods, a Service is needed to expose a pod (or multiple pods) to the network. Services also have the capability to expose things to the outside world. For the frontend, the backend, and the mongodb deployments, there are services for each, allowing the different pods to communicate to each other.</p>"},{"location":"infrastructure/kubernetes/#production-setup","title":"Production Setup","text":"<p>All components of the system are ran with Kubernetes, within Pods. The frontend, backend, and database are each created through a Deployment, which creates a single Pod. Runners, which run the experiments, are created through Jobs, aimed to complete the task within a Pod and exit when finished. Jobs are created only when an experiment is submitted. This is done with the python-kubernetes client in the backend communicating with the kube-apiserver with an in-cluster config that allows it to interact with the cluster while inside the cluster.</p>"},{"location":"infrastructure/kubernetes/#secrets","title":"Secrets","text":"<p>Environmental variables and other encrypted information often need to be used within these pods. Since our system has a <code>.env</code> file, we need a way to prevent the production keys and information from being found. With Kubernetes, this is done through Secrets, which holds encrypted data. You should treat secrets in a similar fashion to the <code>.env</code> file.</p> <p>This is still unsafe to be published on a public server like Github, as it is only encrypted with base64. To work around this, we currently avoid storing the file on Github, saving it on our private Discord server instead. In the future, we may use one-way encrypted secrets to store our production server's secrets more easily, or, more likely, a combination of Helm and Kustomize to be more flexible with other setups. A brief description of Helm is described further down, skip ahead for more information.</p>"},{"location":"infrastructure/kubernetes/#storage","title":"Storage","text":"<p>Since Pods are basically containers, the data they have are also contained within the Pod itself. However, when Pods get destroyed and recreated, that data gets destroyed as well, replaced with whatever the image contained. This is explained in greater detail in the Kubernetes Volume documentation.</p> <p>To fix this, Kubernetes has PersistentVolumes, which stores data independent of a Pod. They work with PersistentVolumeClaims, which is a request for storage resources, like a disk or directory on a Node. Combined together, they allow the system to store and read data external to the Pods. This is used mainly for database data.</p> <p>On the current production server, the data that mongodb interacts with is stored locally, with a local volume. However, more typical setups on the cloud usually use managed block storage on the cloud. Since this project is still small, local volumes work fine for now.</p> <p>Maybe in the future, shifting to Longhorn or something similar for storage will be a good idea.</p>"},{"location":"infrastructure/kubernetes/#helm","title":"Helm","text":"<p>Helm is a tool that packages entire Kubernetes applications. Just like how images are packages of a containerized application or program, Helm works with Charts, which package applications written to work using Kubernetes. This is a more standard way of installing applications onto a Kubernetes cluster, and many charts are stored on Artifact Hub.</p> <p>To use helm, the project must be restructured to fit what it expected such that it can be packaged into a chart. This video may be a helpful resource, though there are other explanations online that may work better. The current development team has little experience with Helm, so as a result, this section is lacking in a full explanation.</p> <p>We are currently using Helm to deploy NGINX-ingress and MongoDB. See the Monorepo/helm_packages.</p>"},{"location":"infrastructure/used_technologies/","title":"Used Technologies","text":"<p>These are the technologies used currently with GLADOS.</p>"},{"location":"infrastructure/used_technologies/#authjs","title":"Auth.js","text":"<p>Auth.js is the library that is used for authentication on GLADOS.</p> <p>OAuth authentication is the Auth.js type used on GLADOS. The Next.js version is used, since Next.js is already being used in the frontend.</p> <p>Thanks to OAuth, GLADOS users can log into the website by using their GitHub account.</p> <p>Learn more about Auth.js on their website.</p>"},{"location":"infrastructure/used_technologies/#mongodb","title":"MongoDB","text":"<p>The database GLADOS uses is MongoDB. Modifying the GLADOS database itself can be done by using MongoDBCompass. See how MongoDB is used with deployment here.</p> <p>Learn more about MongoDB on their website.</p> <p>Learn more about MongoDBCompass here.</p>"},{"location":"infrastructure/used_technologies/#tilt","title":"Tilt","text":"<p>Tilt is a local development tool for Kubernetes. Its purpose in GLADOS is to allow for developers to test their changes on a local version of GLADOS, as testing local changes with Kubernetes is difficult thanks to how it operates.</p> <p>Tilt allows for live updating for the local version of GLADOS; so if a developer makes a change in their code, Tilt will automatically update the local GLADOS website to reflect that. This is particularly useful when making changes on the frontend, helping speed up the process of local development drastically.</p> <p>See how Tilt is used for local testing here.</p> <p>Learn more about Tilt on their website.</p>"},{"location":"infrastructure/used_technologies/#vscode-dev-containers","title":"VSCode Dev Containers","text":"<p>Visual Studio Code has an extension called 'dev_containers', which allows for developer containers to be run in VSCode specifically. By using this extension, developers of GLADOS can let VSCode do most of the Docker work for them. This is the vehicle for developing locally with GLADOS in an effective way.</p> <p>See how dev containers help with local deployment here.</p> <p>Learn more about VSCode Dev Containers here.</p>"},{"location":"infrastructure/vms/","title":"Glados Virtual Machines","text":"<p>To run the cluster we have created several virtual machines that are hosted by Rose-Hulman. The docs below will layout how these virtual machines are structured.</p> VM Host Name Description Specs What runs here? glados-cp This VM will run the kubernetes control plane. See above for the function of the control plane 2 CPU cores, 4GB of RAM, 50GB of storage control-plane glados-db This VM will run and store the MongoDB. 4 CPU cores, 8GB of RAM, 1TB of storage?, ability to run AVX instructions database glados-w1 This will be a general worker node. 4 CPU cores, 8GB of RAM, 50GB of storage non-specific glados-w2 This will be a general worker node. 4 CPU cores, 8GB of RAM, 50GB of storage non-specific glados-dev This will run a cluster used for development. Basically a staging environment. 4 CPU cores, 8GB of RAM, 100GB of storage Entire cluster glados-forge This will run individual VMs for development containers. 16 CPU cores, 32GB of RAM, 500GB of storage Dev containers <p>Note</p> <p>If we need more worker nodes they can follow the scheme above, glados-w3, glados-w4, etc.</p>"},{"location":"infrastructure/vms/#justification","title":"Justification","text":"<p>The glados host name will only run the control plane because it will be able to keep running in the case that another system goes down. The control plane is able to redistribute tasks in the case of a system crash. This system does not need a lot of resources since it is only directing the work to the rest of the cluster.</p> <p>Glados-db will run the MongoDB, this means that it may need quite a bit of persistent storage. Therefore we need quite a bit of storage on this VM. MongoDB also appears to be quite resource intensive.</p> <p>Glados worker nodes can all be the same specs and can be spun up/down as they are needed. When adding/removing nodes you will have to instruct the control plane to do so.</p>"},{"location":"infrastructure/vms/#development-environment","title":"Development Environment","text":"<p>We would also like a VM to run a development version of GLADOS for our own testing.</p>"},{"location":"infrastructure/vms/#hostname","title":"Hostname","text":"<p>glados-dev</p>"},{"location":"infrastructure/vms/#description","title":"Description","text":"<p>Run the cluster on a single machine for testing purposes.</p>"},{"location":"infrastructure/vms/#specs","title":"Specs","text":"<p>4 CPU cores, 8 GB RAM, 100GB storage</p> <p>We might need a little extra storage due to kubernetes caching old images. We will have to make sure we clean this up periodically.</p>"},{"location":"infrastructure/vms/#physical-server","title":"Physical Server","text":"<p>We will continue to use the physical GLADOS server in the cluster. We will use the physical server as a worker node (worker 0). The physical server will now have the hostname glados-w0.</p>"},{"location":"infrastructure/vms/#glados-forge","title":"glados-forge","text":"<p>This VM is used for development purposes for the GLADOS team. It is configured to create and manage development environments for each member of the GitPod organization, allowing each person to maintain their own environment and changes for the work they are completing to enhance the system.</p> <p>The development environments are dynamically spun up and down as needed to preserve the ram and CPU usage on the VM.</p>"},{"location":"tutorial/best_practices/","title":"Best Practices","text":"<p>This page will give a brief overview of the best practices for using GLADOS. For more detailed information on the sections, see the attached links to the relevant areas of the documentation or system technology documentation.</p>"},{"location":"tutorial/best_practices/#repository-structure","title":"Repository Structure","text":"<p>The GLADOS repository is structured to allow for easy navigation and understanding of the system. The main components of the repository are:</p>"},{"location":"tutorial/best_practices/#code-structure","title":"Code Structure","text":"<ul> <li> <p>Backend: The backend code is located in the <code>apps/backend</code> directory. This contains all the code for the backend APIs. Since GLADOS is mainly a kubernetes structure with a NextJS frontend, the backend code is mainly for the API calls to start/cancel experiments and the database calls to get the data for the frontend. The backend code is written in Python.</p> </li> <li> <p>Frontend: The frontend code is located in the <code>apps/frontend</code> directory. This contains all the code for the web application, including the React components and styles. The frontend code is written in TypeScript and uses Next.js for server-side rendering and routing. Most of the mongoDB and Kubernetes API calls are handled in the server-side code of the Next.js application, found in <code>lib/mongo_funcs.ts</code> and <code>lib/k8s_funcs.ts</code>.</p> </li> <li> <p>Runner: The runner code is located in the <code>apps/runner</code> directory. This is the code that the kubernetes cluster creates for a experiment. It handles the parameter parsing, experiment running, and result collection. The runner code is written in Python.</p> </li> <li> <p>Documentation: The documentation for GLADOS is located in the <code>docs</code> directory. This contains all the documentation for the system, including the user guide, developer guide, and API documentation. The documentation is written in Markdown and is generated using MkDocs.</p> </li> </ul>"},{"location":"tutorial/best_practices/#branching-strategy","title":"Branching Strategy","text":"<p>The GLADOS repository uses a branching strategy to manage the development process. The main branches are:</p> <ul> <li> <p>main: This is the main branch of the repository. All changes to the code should be made in a separate branch and then merged into the main branch after review. At least one other developer should review the code before it is merged into the main branch. The main branch is protected and cannot be directly pushed to.</p> </li> <li> <p>dev: This is the development branch of the repository. All new features and changes should be made in a separate branch off of the dev branch. The dev branch is not protected and can be pushed to directly. This is a space to test the changes on a kubernetes cluster that has one node before being merged into the main branch. The dev branch is used for testing and development purposes only.</p> </li> <li> <p>feature branches: These are the branches that are created for new features or changes. The current dev team should come up with a naming convention for the feature branches. This is where the new features and changes are developed and locally tested using the live updating functionalities of Tilt and the dev containers on glados-forge.</p> </li> </ul>"},{"location":"tutorial/best_practices/#dev-environment","title":"Dev Environment","text":"<p>The development environment for GLADOS is streamlined using the glados-forge VM, Gitpod, and Dev Containers. See the Development Environment page for more information on how to set up your development environment. For more information on glados-forge, see the VMs page.</p>"},{"location":"tutorial/best_practices/#task-board","title":"Task Board","text":"<p>The task board for GLADOS is located in the GitHub Projects. This is where all of the tasks/issues for GLADOS are tracked and managed. The current dev team should create a standard for how to name and track time for the tasks/issues that they are working on. In the past, the naming convention has been to use the following format: '[Task Name] - _/[Number of Hours Predicted]'. This way the person who is assigned to the task can update the time as they are working. </p>"},{"location":"tutorial/best_practices/#task-board-categories","title":"Task Board Categories","text":"Category Description TroubleShooting Issues with bugs that need further fixing before they can be marked as done. Consult Jason Issues that are roadblocked and require clarification or input from Jason before progress can be made. Onboarding Good starter issues for new teams. Look here first if you\u2019re not sure what to work on. Backlog Issues that need to be done and haven\u2019t been started yet, but are not currently prioritized. Ready Issues that have not been started yet and are ready for someone to pick up. Roadblocked Issues that cannot progress because they require changes from another team member. On Hold Issues that were in progress but are paused due to other priorities. In Progress Issues currently being worked on by someone. In Review Issues completed and waiting for review by other team members before merging. Done Issues that have been completed. Eventually Issues that need to be completed, but cannot be addressed for the foreseeable future. <p>GitHub has also implemented a sub-task feature that allows for the creation and management of smaller tasks that can combine into a larger feature. This is a great way to  both split up work on a large feature between people and better track the time that each part of the feature is taking. </p> <p>Another important feature of the task board is the ability to assign labels for importance of the task and assign the development branch that is being used to complete the work for that task. Utilizing these task board management features will help the team stay organized and on track with the development of GLADOS.</p>"},{"location":"tutorial/best_practices/#code-reviews","title":"Code Reviews","text":"<p>All code changes should be reviewed by at least one other developer before being merged into the main branch. This is to ensure that the code is of high quality and meets the standards of the project. The code review process should include:</p> <ul> <li>A review of the code for readability and maintainability. (No unnecessary comments, clear variable names, etc.)</li> <li>A review of the code for correctness and functionality. (Do not push failing code to the main branch.)</li> <li>A review of the code for performance and efficiency. (Do not push code that is slow or inefficient to the main branch.)</li> <li>A review of the code for security and safety. (Do not push code that is insecure or unsafe to the main branch.)</li> </ul> <p>If anything needs to be changed, comment on the pull request and request changes. Once the changes have been made, approve the pull request and merge it into the main branch. If you are not sure about a change, ask for help from another developer or the project lead.</p> <p>Note</p> <p>As of Spring 2025, GitHub has added GitHub Copilot to the code review process. This is a great way to get suggestions for code changes and improvements. However, it is important to remember that this is just a suggestion and should not be used as a replacement for a human code review.</p>"},{"location":"tutorial/deployment/","title":"Production Deployment","text":"<p>The deployment process for GLADOS has been made easy for any admin on the system.</p> <p>Note</p> <p>A change needs to be reviewed, approved, and merged into the <code>main</code> branch. Then, the GitHub Actions to build the new production images needs to be completed before a deployment can be performed.</p> <p>There are two ways to do a production deployment:</p> <ol> <li>On the Frontend</li> <li>SSH through the glados.csse.rose-hulman.edu Server</li> </ol>"},{"location":"tutorial/deployment/#on-the-frontend","title":"On the Frontend","text":"<p>This method is the primary method of deploying new changes to GLADOS and will work 99% of the time.</p> <p>To complete this method:</p> <ol> <li>Ensure that the user on GLADOS is an Admin.</li> <li>Go to the Admin dashboard and select the appropriate deployment section.</li> <li>There will be a red Redeploy button. Clicking this button will redeploy the application images and may take up to a couple of minutes.</li> <li>Refreshing the page or opening it in a new tab will show when the application is back up and running.</li> </ol>"},{"location":"tutorial/deployment/#through-the-server","title":"Through the Server","text":"<p>This is the backup method of completing a redeployment for GLADOS. It should only be used when the frontend redeployment button is not working properly.</p> <p>To complete a redeployment this way:</p> <ol> <li>Connect to the main GLADOS server by using the main account found in the Dev Team shared files.</li> <li>Use SSH to log in to the server.</li> <li>From the main page of the server CLI, run:</li> </ol> <pre><code>./Deploy-Server\n</code></pre> <p>This will deploy the newly created images in the same fashion as the frontend button. Refreshing the page will show when the changes are live.</p>"},{"location":"tutorial/usage/","title":"Usage","text":"<p>This section covers how to run an experiment on the system.</p>"},{"location":"tutorial/usage/#definitions","title":"Definitions","text":"<ul> <li>Trial: A single run of submitted code with a corresponding config file.</li> </ul>"},{"location":"tutorial/usage/#accessing-the-system","title":"Accessing the System","text":"<p>When connected to the Rose-Hulman network, you can access the live system at https://glados.csse.rose-hulman.edu/.</p> <p>If you need a local copy of the system, refer to the installation guide.</p> <p>You must sign in with either a Google or GitHub account to run an experiment.</p>"},{"location":"tutorial/usage/#preparing-your-code","title":"Preparing Your Code","text":"<p>GLADOS has limited support for experiments. To ensure your experiment runs properly, check whether it meets the compatibility requirements.</p> <p>The main steps to prepare an experiment are:</p> <ol> <li>Ensure GLADOS supports your experiment. Details are available under Compatibility.</li> <li>Use a <code>.ini</code> file to input parameters, passed as a command-line argument.</li> <li>Output results to a CSV file, or return a single value as the output.</li> </ol> <p>We provide example experiments in the repository. Consider using them as a guideline for formatting your experiment.</p> <p>Your experiment must be configured to accept a <code>.ini</code> config file structured as follows:</p> <pre><code>[DEFAULT]\ng = 5\np = 50\ngl = 1\nmr = 0.2\ns = 1\n</code></pre> <p>You can format the generated <code>.ini</code> file using the \"User Defined Constants\" tab while creating an experiment. Use curly brackets <code>{}</code> to reference parameter names.</p> <p>Example:</p> <p>If you have a parameter named <code>seed</code> ranging from 1 to 10 (incrementing by 1), you can define it in the \"User Defined Constants\" tab as:</p> <pre><code>[SEED]\nrandom_seed = {seed}\n</code></pre> <p>This allows additional <code>.ini</code> sections to be included dynamically.</p> <p>Your experiment must also output results in a two-line CSV format with headers and corresponding values:</p> <pre><code>HeaderFor1, HeaderFor2\nResult1, Result2\n</code></pre> <p>Note: If your CSV file contains more than two lines, you can specify which line should be used in the \"Information\" tab.</p> <p>Java experiments must be packaged as an executable <code>.jar</code> file. C experiments must be compiled into a Unix binary executable (for basic users). Specific requirements are outlined under Compatibility.</p> <p>Once your experiment is set up, proceed to Running the Experiment.</p>"},{"location":"tutorial/usage/#compatibility","title":"Compatibility","text":"<p>GLADOS supports experiments that:</p> <ul> <li>Run on Python 3.8 as a single Python file.</li> <li>Are packaged as an executable <code>.jar</code> file.</li> <li>Are compiled into a binary executable for Unix systems, runnable on a base Debian system.</li> <li>Are contained in a zip file that includes one of the above file types.</li> </ul> <p>Other experiment types may be supported, but testing is limited. Use at your own risk.</p> <p>GLADOS supports complex outputs, including multiple files. However, data aggregation is currently limited to a single file.</p> <p>After completion, you can download all generated files, organized by each trial run, in a Project Zip.</p> <p>Future updates will improve support for dependencies and additional experiment types.</p>"},{"location":"tutorial/usage/#extra-features","title":"Extra Features","text":"<p>Note: These files can only be provided inside of zip files!</p> <p>Users can provide a file called \"userProvidedFileReqs.txt\". This file is a Python requirements file. When this file is provided all packages will be automatically installed.</p> <p>Privileged users have the option to provide two files:</p> <ul> <li> <p>packages.txt - this contains Debian packages to be installed to the runner.</p> </li> <li> <p>commandsToRun.txt - this file contains bash commands that will be run on the runner after packages have been installed.</p> </li> </ul>"},{"location":"tutorial/usage/#running-experiments","title":"Running Experiments","text":"<p>To create a new experiment, click the \"New Experiment\" button below your email in the top-left corner of the dashboard.</p> <p>Upon first login, your dashboard will be empty.</p> <p></p> <p>To run a default experiment, click the \"Run a Default Experiment\" button on the right side of the screen.</p> <p></p> <p>You will see a modal where you can select \"Add Nums (Python).\" This will present an already configured experiment.</p> <p></p> <p>The experiment creation interface consists of multiple tabs:</p>"},{"location":"tutorial/usage/#information-tab","title":"Information Tab","text":""},{"location":"tutorial/usage/#name-required","title":"Name (Required)","text":"<p>The name displayed in the UI for this experiment.</p>"},{"location":"tutorial/usage/#description-optional","title":"Description (Optional)","text":"<p>A description stored with the experiment record.</p>"},{"location":"tutorial/usage/#trial-result-required","title":"Trial Result (Required)","text":"<p>The CSV file captured as the experiment result.</p>"},{"location":"tutorial/usage/#trials-extra-file-optional","title":"Trial's Extra File (Optional)","text":"<p>A folder or file included in the downloadable Project Zip after experiment completion.</p>"},{"location":"tutorial/usage/#trial-timeout-hours-required","title":"Trial Timeout (hours) (Required)","text":"<p>The duration before the experiment automatically times out.</p>"},{"location":"tutorial/usage/#executable-file-required-for-zip-experiments","title":"Executable File (Required for zip experiments)","text":"<p>If using a zip experiment, specify the main executable filename.</p>"},{"location":"tutorial/usage/#keep-logs-required","title":"Keep Logs (Required)","text":"<p>Select this option to store logs from the experiment runner pod.</p>"},{"location":"tutorial/usage/#parameters-tab","title":"Parameters Tab","text":"<p>There are five parameter types:</p>"},{"location":"tutorial/usage/#integer","title":"Integer","text":"<ul> <li>Name: The parameter name used in the <code>.ini</code> file.</li> <li>Min: Minimum value.</li> <li>Max: Maximum value.</li> <li>Step: Increment value.</li> <li>Default (if enabled): The default value used when generating permutations.</li> </ul>"},{"location":"tutorial/usage/#float","title":"Float","text":"<p>Similar to Integer but supports decimal values.</p>"},{"location":"tutorial/usage/#boolean","title":"Boolean","text":"<ul> <li>Name: The parameter name.</li> <li>Value: <code>true/false</code></li> <li>Default (if enabled): Used in permutation generation.</li> </ul>"},{"location":"tutorial/usage/#string-list","title":"String List","text":"<ul> <li>Name: The parameter name.</li> <li>Edit String: Defines a list of strings to iterate over in permutations.</li> <li>Default (if enabled): Used in permutation generation.</li> </ul>"},{"location":"tutorial/usage/#parameter-group","title":"Parameter Group","text":"<ul> <li>Name: The parameter group name.</li> <li>Parameters: The parameter groupings that will be tested together in an experiment run.</li> <li>Default (if enabled): Used in permutation generation.</li> </ul>"},{"location":"tutorial/usage/#user-defined-constants-tab","title":"User Defined Constants Tab","text":"<p>This tab allows defining a text block appended to every generated <code>.ini</code> config file. You can use parameters from the \"Parameters\" tab inside curly brackets.</p> <p>Example:</p> <pre><code>[DEFAULT]\ntest_var = {test}\n</code></pre>"},{"location":"tutorial/usage/#post-process-tab","title":"Post Process Tab","text":"<p>This tab allows you to include a scatter plot in the downloadable Project Zip. This feature will be replaced by ChartJS functionality on the dashboard in future updates.</p>"},{"location":"tutorial/usage/#confirmation-tab","title":"Confirmation Tab","text":"<p>This tab allows you to review all hyperparameters and settings before running the experiment.</p>"},{"location":"tutorial/usage/#dispatch-tab","title":"Dispatch Tab","text":"<p>You can start an experiment from this tab by either:</p> <ol> <li>Selecting a file from the five most recent ones used.</li> <li>Uploading a new file.</li> </ol> <p>If you copied an experiment, the file will be preselected.</p>"},{"location":"tutorial/usage/#results","title":"Results","text":"<p>After dispatching the experiment, it will take a little bit before starting.</p> <p></p> <p>Once the experiment starts, you can monitor progress in real time.</p> <p>The dashboard will display:</p> <ul> <li>Total trials.</li> <li>Completed trials.</li> <li>Successes and failures.</li> <li>Estimated time to completion.</li> </ul> <p>Example below:</p> <p></p> <p>For longer experiments, you can click the \"Open Live Log\" button to see live log updates from the configurations files. It updates every 5 seconds. This can help you identify when an error occurred mid experiment run.</p> <p>You can cancel an experiment at any time. However, small experiments may finish before cancellation takes effect.</p> <p>Note: The \"Expected Total Time\" metric does not account for parallel execution, so actual completion may be faster.</p> <p>Example of completed experiment:</p> <p></p> <p>After completion, you can download the <code>results.csv</code> file, which contains output data and configurations for each trial. If extra files were generated, logs were kept, or post-processing was applied, a zip file will also be available.</p> <p>To rerun an experiment with modified parameters, click \"Copy Experiment.\"</p> <p>To visualize results, click \"See Graph\" on the dashboard.</p> <p>Experiments can also be shared with other users. Click \"Share Experiment\" to copy a shareable link. Shared users can view but not delete the experiment.</p> <p>By clicking on \"Archive Experiment\", you can hide the experiment from view. You can see archived experiments by clicking on the \"Filter\" button and toggling \"Include Archived\".</p> <p></p> <p>If you don't have any further use for an experiment, feel free to delete it by clicking \"Delete Experiment\".</p> <p></p> <p>In order to select experiments, you need to turn on \u2018Edit Mode\u2019, which is off by default. You will find it below the 'Expand All' and 'Collapse All' buttons. Each experiment will have a radio button to the left of it that allows you to select it. This enables you to delete or archive as many selected experiments as you would like.</p> <p></p> <p>By default, experiments will be open, and will all reopen on refresh of the page. In order to close all of your experiments, you can use the \u2018Select All\u2019 button under \u2018Edit Mode\u2019.</p>"},{"location":"tutorial/usage/#permutations","title":"Permutations","text":"<p>This section explains how parameter permutations are generated.</p>"},{"location":"tutorial/usage/#example-1-no-defaults","title":"Example 1: No Defaults","text":"<p>An integer parameter <code>test</code> with:</p> <ul> <li>Min: <code>1</code></li> <li>Max: <code>10</code></li> <li>Step: <code>1</code></li> </ul> <p>will generate 10 configurations:</p> <pre><code>[DEFAULT]\ntest=1\n</code></pre> <pre><code>[DEFAULT]\ntest=2\n</code></pre> <p>... up to <code>test=10</code>.</p> <p>Note: Every parameter will go under the [DEFAULT] header unless defined in the \"User Defined Constants\" tab.</p>"},{"location":"tutorial/usage/#example-2-using-defaults","title":"Example 2: Using Defaults","text":"<p>An integer parameter <code>x</code> with:</p> <ul> <li>Min: <code>1</code></li> <li>Max: <code>10</code></li> <li>Step: <code>1</code></li> <li>Default: <code>1</code></li> </ul> <p>An integer parameter <code>y</code> with:</p> <ul> <li>Min: <code>11</code></li> <li>Max: <code>20</code></li> <li>Step: <code>1</code></li> <li>Default: <code>11</code></li> </ul> <p>An stringlist parameter <code>test</code> with:</p> <ul> <li>Values: <code>[\"one\", \"two\", \"three\"]</code></li> <li>Default: <code>two</code></li> </ul> <p>will generate 21 configurations (after duplicates are removed):</p> <pre><code>[DEFAULT]\nx=1\ny=11\ntest=\"two\"\n</code></pre> <pre><code>[DEFAULT]\nx=2\ny=11\ntest=\"two\"\n</code></pre> <p>... up to <code>x=10, y=11, test=\"two\"</code></p> <pre><code>[DEFAULT]\nx=1\ny=11\ntest=\"two\"\n</code></pre> <pre><code>[DEFAULT]\nx=1\ny=12\ntest=\"two\"\n</code></pre> <p>... up to <code>x=1, y=20, test=\"two\"</code></p> <pre><code>[DEFAULT]\nx=1\ny=11\ntest=\"one\"\n</code></pre> <pre><code>[DEFAULT]\nx=1\ny=11\ntest=\"two\"\n</code></pre> <pre><code>[DEFAULT]\nx=1\ny=11\ntest=\"three\"\n</code></pre> <p>That will be all generated permutations.</p> <p>Note: Some of the examples shown were duplicates and would be removed automatically.</p>"},{"location":"tutorial/usage/#chart","title":"Chart","text":"<p>After the experiment has completed, you can view the chart by clicking \"See Graph\". This will bring up the chart modal.</p> <p>Example below:</p> <p></p> <p>You can toggle fullscreen mode or close the modal by using the buttons in the top right of the modal.</p> <p>You can change the chart type by using the buttons along the top. Currently, bar charts, line charts, pie graphs, box plots, and violin plots are supported.</p> <p>The chart accesses the results file generated by the experiment, \"results.csv\", and separates the columns. You can select which column is used as the x-axis using the dropdown below the chart. You can then toggle the visible y-axis columns by clicking the colored boxes along the top of the chart.</p> <p>You can set the y-axis range used by the chart by entering numbers into the \"Y-Axis Scale\" inputs below the chart. If you don't input a valid number, the chart will use its default range, which displays all data points. If you input a range that hides data points on any visible y-axis column, a warning will appear to remind you of this.</p> <p>If the selected x-axis column has multiple entries with the same value, you can choose to aggregate the entries together by toggling the checkbox below the chart and selecting the preferred mode of aggregation. The y-axis values with the same x-axis value will be combined using the chosen method. For example, if you enabled aggregation using the \"average\" mode and your results looked like this:</p> x y 0 1 0 3 1 5 1 7 <p>The resulting chart would show two values:</p> x y 0 2 1 6 <p>Currently, sum, count (number of values), average, median, and mode are supported.</p> <p>Note: Box plots and violin plots aggregate the x-axis by default, and do not support toggling of this feature.</p> <p>Finally, you can download the resulting chart as an image by clicking the \"Download Image\" button at the bottom of the modal. The image should automatically begin downloading as a .png file. If desired, using fullscreen mode can provide a larger chart.</p>"},{"location":"tutorial/usage/#known-bugs","title":"Known Bugs","text":"<ul> <li>If an experiment crashes, users are not notified. If an experiment is stuck on \"Experiment Awaiting Start\" or a trial takes too long, it has likely failed. A fix is in progress.</li> </ul>"}]}